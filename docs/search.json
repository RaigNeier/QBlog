[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Author",
    "section": "",
    "text": "Hello, my name is Peter aka Raig Neier. For as long as I can remember, I have always been fascinated by electronics. It’s like some kind of magic that once built work by itself. But most of all I enjoyed programming it and especially the games.\nMy interest was first piqued by a Nintendo game console that I borrowed from a friend for a few months when he moved to another city. Sometimes I think what is so special about Super Mario? But as the first game in my life after TETRIS, it made an indelible impression on me. Then it was SEGA, then the computer and the first book on Turbo Pascal.\nI’ve always been fascinated by how in games the story came to life and moved, but you could also influence it. It turned out to be much more interesting than reading or watching movies. And now I’m stuck for life trying to figure out how to learn this magic=)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GameDev Blog",
    "section": "",
    "text": "Arkanoid Series 05 : Game Loop\n\n\n\n\n\n\n\nArkanoid\n\n\n\n\n\n\n\n\n\n\n\nApr 16, 2023\n\n\nPeter Remyga\n\n\n\n\n\n\n  \n\n\n\n\nArkanoid Series 04 : Input Handling\n\n\n\n\n\n\n\nArkanoid\n\n\n\n\n\n\n\n\n\n\n\nApr 15, 2023\n\n\nPeter Remyga\n\n\n\n\n\n\n  \n\n\n\n\nArkanoid Series 03 : Creating a project\n\n\n\n\n\n\n\nArkanoid\n\n\n\n\n\n\n\n\n\n\n\nApr 14, 2023\n\n\nPeter Remyga\n\n\n\n\n\n\n  \n\n\n\n\nArkanoid Series 02 : Setup and Tools\n\n\n\n\n\n\n\nArkanoid\n\n\n\n\n\n\n\n\n\n\n\nApr 13, 2023\n\n\nPeter Remyga\n\n\n\n\n\n\n  \n\n\n\n\nArkanoid Series 01 : Introduction\n\n\n\n\n\n\n\nArkanoid\n\n\n\n\n\n\n\n\n\n\n\nApr 12, 2023\n\n\nPeter Remyga\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nApr 11, 2023\n\n\nPeter Remyga\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Arkanoid/01/index.html",
    "href": "posts/Arkanoid/01/index.html",
    "title": "Arkanoid Series 01 : Introduction",
    "section": "",
    "text": "Arkanoid Series Introduction.\nThis will be the first tutorial in series where we develop famous game Arkanoid!\nI think every game developer should build its own Arkanoid at least once. This very simple and yet interesting project as your first one that allow you learn the basics and have some fun.\n\nDuring this series you will learn:\n\nhow to setup visual studio\nC# programming, “syntax sugar”\nWindows Forms GDI+ graphics\nuseful classes to build another games and GUI apps on Windows Forms\nhow to use nuget packages\nconcept of Game Loop\nhow to gradually build and imrove your game\nhow to build a level editor\nrapid prototyping\n\n\n \nOr here is a link to a finished game prototype repository on my GitHub: Arkanoid by Raig Neier\nNext &gt;&gt; : Setup and Tools"
  },
  {
    "objectID": "posts/Arkanoid/02/index.html",
    "href": "posts/Arkanoid/02/index.html",
    "title": "Arkanoid Series 02 : Setup and Tools",
    "section": "",
    "text": "Setting up environment and installing tools.\nFirstly you need download Visual Studio Community 2022. Download Visual Studio &gt;&gt;&gt; \nBy a link you should get a VisualStudioSetup.exe installer. Installation is very simple i will not cover it here. When you reach component selection the only thing we need is to select .NET desktop development component:\n\n\n\n\n\nNext &gt;&gt; : Creating a Project in Visual Studio\n&lt;&lt; Previous : Introduction"
  },
  {
    "objectID": "posts/Arkanoid/03/index.html",
    "href": "posts/Arkanoid/03/index.html",
    "title": "Arkanoid Series 03 : Creating a project",
    "section": "",
    "text": "Creating a project for a game.\n\nSteps\n\nLaunch Visual Studio\nSelect Create new Project.\nSelect Windows Forms App Template.\nFell free to give it a name you like, this your game.\nFinish project creation keeping everything else as default options.\n\n\nAfter you project is created. We need to install a NuGet package to easily work with JSON fles We will use them to store our settings and levels:\n\nTo install this NuGet Package:\n\non the top menu strip select Project -&gt; Manage NuGet Packages\nthen to the Browse Tab.(You should have internet connection to install NuGet)\nsearch for package Newtonsoft.Json and install it\n\nNext thing we gonna need is to set some basic settings\n\nThere should be “Form1” form created by default, change its name to something like GameWindow\nCreate new class a call it GameWindow_Logic, we will separate basic window code and our actual game code from the start to remove the distractions.\nNext copy all the code from our GameWindow and using it replace everything in the GameWindow_Logic. After that remove GameWindow class contents inside GameWindow_Logic file. C# allow to split one class between several files if it has partial modifier in its definition. And when form is created by visual studio it has partial modifier by default.\nin the GameWindow after initialize component add : “this.DoubleBuffered = true;”. Cause in games we need redraw screen very often. If this process happens on the screen does not matter how quick it is flickering is inevitable. This option enable form to use second buffer to paint content and swap with the first one. That way actual drawing process is invisible to the user and there will be no flickering.\nat last add another form and call it LevelEditorForm\n\n\nYou shoud end up with something like this:\n// GameWindow.cs file content\nnamespace Game {\n    public partial class GameWindow: Form {\n        public GameWindow() {\n            InitializeComponent();\n            this.DoubleBuffered = true; // this will remove flickering\n        }\n    }\n}\n\n// GameWindow_Logic.cs file content\nnamespace Game {\n    public partial class GameWindow: Form {\n\n    }\n}\n\n// LevelEditorWindow.cs file content\nnamespace Game {\n    public partial class LevelEditorWindow: Form {\n        public LevelEditorWindow() {\n            InitializeComponent();\n        }\n    }\n}\nAs you can see we will be implementing level editor for our game in the same project just as a separate window. That way we can share same file system between two separate modules and easily switch between them.\nAfter we finish the basics I will show you more complex ways to organize files and make application integration.\n\nHere is GameDev advice: during rapid prototyping and early stages of development use simplest and quickest ways to make you program running and dont allow the mundane “right ways” stuck in your “creativity wheel” on each step you\ntake or you will be tired very quickly.\n\nOkay. About mundane tasks…\nNext thing we need to create a directory structure and add default image of the ball and paddle we will usein our game.\nLets create a resources file structure for our game. Look at this picture as a reference and create folders on top level of the project:\n\n\n\n\n\nBut when our game or level editor will be searhing for Data folder, it did not find it in output folder of compilied project since they are on the top level of our project. Some developers after they adding some image they go to its the properties and set option: Copy if newer. But imagine if we constantly creating new levels or adding new resources during development? I certain that will be very quickly annoyed by this not to mention you will keep forgetting about this and would be wondering why your game cant find some resource… So, instead let’s just add this line: “string ResPath = \"..\\\\..\\\\..\\\\Data\\\\\";” to the main classes in GameWindow and LevelEditorWindow:\n// GameWindow.cs file content\nnamespace Game {\n    public partial class GameWindow: Form {\n        string ResPath = \"..\\\\..\\\\..\\\\Data\\\\\";\n\n        public GameWindow() {\n            InitializeComponent();\n            this.DoubleBuffered = true; // this will remove flickering\n        }\n    }\n}\n\n// LevelEditorWindow.cs file content\nnamespace Game {\n    public partial class LevelEditorWindow: Form {\n        string ResPath = \"..\\\\..\\\\..\\\\Data\\\\\";\n\n        public LevelEditorWindow() {\n            InitializeComponent();\n        }\n    }\n}\nIn windows evironment when path contains double dots “..” that means go back one level to the root folder. So if we know what that program output folder deep and out Data folder inside Arkanoid folder three levels higher:\n\n\n\n\n\nWe dont need to know know their name, we just use this : “..\\..\\..\\”.\nTo proceed to the the most interesting part we need to create one very useful and universal class which WindowsForms lacks. So in next tutorial we will create useful Input wrapper for WindowsForms Control class:\nNext &gt;&gt; : Input Handler\n&lt;&lt; Previous : Setup and Tools"
  },
  {
    "objectID": "posts/Arkanoid/04/index.html",
    "href": "posts/Arkanoid/04/index.html",
    "title": "Arkanoid Series 04 : Input Handling",
    "section": "",
    "text": "In this tutorial we will create input handling class.\n\n\n\nPablo Perez Varela/Shutterstock.com\n\n\nSince this class is quite universal, may seem sophisticated at first and working whole for sole purpose, I will not use bullet points here. We will go through each step of its creation gradually to have a deep understanding.\nFirst, create new class named InputHandler and move it into Classes folder. Since we not making a lib don’t update namespace when you asked through popup dialog, that will only get in the way. Or if you create your class inside Classes folder remove Classes from namespace name.\nnamespace Game.Classes {}\nEvery WindowsForms visual component including Form has Control in its base class.\nInputHandler is class works as a wrapper around any Control class descendant collecting its data. Create a var type of Control with name baseControl. And update constructor to get this base control and assign it to local variable :\n    public class InputHandler {\n        private Control baseControl;\n\n        public InputHandler(Control _control){\n            baseControl = _control;\n\n        }\n    }\n\nNext part\nWe need a way to store currently pressed keyboard and mouse keys. Create several lists for storing keys. We using List since it very easy to add and remove items and check for existing keys. Also wheel position and mouse cursor location in side Control.\n        //lists to store:\n        private List&lt;Keys&gt; curKeysDown = new (); // keyboard keys\n        private List&lt;MouseButtons&gt; curMouseBtnDown = new(); // mouse keys\n        private int curWheelDelta = 0; // current mouse wheel position\n        private PointF curMouseLocation = new (); // and cursor position\n\nSyntax sugar tip:\nYou may notice or may not but there was some changes in C#. Before you have to write a full instance creation specifying type:\n    List&lt;int&gt; listOfInt = new List&lt;int&gt;();\nBut in new standard you can omit a type and just write like this:\n    List&lt;int&gt; listOfInt = new();\n\nBefore we move on we need another class to store this input data as snapshot. Game works differently from destkop application. Usually game has a loop that unpdating every 30 or 60 times per second and sometimes even higher.\nGames are fastpace and constantly changing software that have to quickly respond to player input that unpredictable, so we need to make calculations and render everything from scratch every frame to make player experience as smooth as posssible.\n\nUsually we have two methods called each frame:\n\nUpdate Frame -&gt; method where calculation happening\nDraw Frame -&gt; method where draw everything based on calculations\n\n\nEvent based system used by Windows forms to handling user input is another unpredictable variable that working good in static UI’s, but no use in games. We can’t predict when event happens. To adress this we created list to store current input data, so it doesnt interfere with our stable Game Loop. And can be accessed when its needed instead. Even with all of this talking about speed and rsponsiveness this is may seem contradicting cause there are some latency when we check input only when we need. But this “need” happens so often in game loop so there are almost no noticeable latency.\nBut what if you want to know when key is pressed or released? Just now in this frame or already for some time?\nThis is why need another class to store input data snapshots from frame to frame. Create a class InputState inside same file or new, it does not matter since it used by a InputHandler. You can even put its implementation at the top of InputHandler.\n\nin this class we creating:\n\nsame variables to store snapshot of InputHandler input data.\ntwo constructors:\n\none as default empty state, when the game starts\nanother to make a snapshot but throwing InputHadler data as is\n\nGetCopy() method. That makes a new instance of InputState, using this class input data. We need this cause when we assing class instance to another class instance its just assign reference not a copy. And if something is gonna happen with a original object same happens with this instance we assigned it to. I will show where it may happen later\n\nAt last low-level data retrievers, that are used only by another functions of InputHandler.\n\ntwo functions that returning if key is pressed in current state\n\nfor mouse buttons IsMouseDown()\nfor keyboard keys IsKeyDown()\n\nand two getters\n\nmouse cursor location\nmouse wheel postition\n\n\n\nLook at what we have, there is nothing sophisticated just copy it as is:\n    public class InputState {\n         \n        private PointF mouseLocation = new ();\n        private List&lt;Keys&gt; keysDownList = new ();\n        private List&lt;MouseButtons&gt; mouseBtnDownList = new ();\n        private int wheelPosition = 0;\n\n        public InputState() { }\n\n        public InputState(List&lt;Keys&gt; _keysDownList, List&lt;MouseButtons&gt; _mouseBtnDownList, PointF _mousePosition, int _wheelPosition) {\n            keysDownList = _keysDownList;\n            mouseBtnDownList = _mouseBtnDownList;\n            mouseLocation = _mousePosition;\n            wheelPosition = _wheelPosition;\n        }\n\n\n        public InputState GetCopy() {\n            List&lt;Keys&gt; copyKeysDownList = new List&lt;Keys&gt;(keysDownList.ToArray());\n            List&lt;MouseButtons&gt; copyMouseBtnDownList = new List&lt;MouseButtons&gt;(mouseBtnDownList.ToArray());\n            PointF copyLocation = new PointF(mouseLocation.X, mouseLocation.Y);\n\n            return new InputState(copyKeysDownList, copyMouseBtnDownList, copyLocation, wheelPosition);\n        }\n\n        public bool IsMouseDown(MouseButtons gMouseButtons) =&gt; \n            mouseBtnDownList.Contains(gMouseButtons);\n        public bool IsKeyDown(Keys gKeys) =&gt; \n            keysDownList.Contains(gKeys);\n        public PointF Location =&gt; mouseLocation;\n        public int WheelPosition =&gt; wheelPosition;\n    }\n\nFirst some syntax sugar tips from this code: In a new stadard instead of the:\n    public PointF Location {\n        get { \n            return mouseLocation; \n        } \n        set { \n            mouseLocation = value;\n        }\n    }\nYou can use =&gt; sign:\n    public PointF Location =&gt; mouseLocation;\nSame goes for methods:\n    public PointF OffsetLocation(PointF offset) =&gt; \n    (new PointF(mouseLocation.X + offset.X, mouseLocation.Y + offset.Y);\n\nAnd back to our InputHandler method, after we created InputState class we can start building it.\nCreate a states for previous and current frame. Add this to your variables:\n        // states that used to make snapshot of input data each frame\n        private InputState currentState = new();\n        private InputState previousState = new();\nCreate a timer variable. Its used it to simulate update loop.\n        // in .NET there are two timers so need to specify \n        // that we want WindowsForms timer\n        private System.Windows.Forms.Timer updateTimer = new();\n\n\n\n\n\n\nNote\n\n\n\nPlease keep in mind that WindowsForms timer component not the most quick and precise. There are custom timers all over the internet if really need them. But there is no point in creating some real game project using windows forms and gdi, better to use some game engine software. But for this project its enough. Main reason i showing this in Windows Forms because its very useful to prototype some ideas not a real battle projects.\n\n\nExpose timer Interval and start/stop methods to the external classes. With interval we can control game speed and start/stop used to pause a loop in some cases you will see later.\n        public int UpdateInterval =&gt; updateTimer.Interval;\n        public void StartUpdateLoop() =&gt; updateTimer.Start();\n        public void StopUpdateLoop() =&gt; updateTimer.Stop();\n\nLast thing we need are custom events:\n\nUpdateFrame()\nDrawFrame()\n\n\nThis events should give access to instance of InputHandler that generate then and GDI+ Graphics of the current frame of the current control InputHandler are wrapping around. That way game itself doesnt know anything of the underlying controls it just have access current live data.\nBecause of that we need to create a custom EventHandler delegate, after that we can use it to create events:\n        public delegate void FrameEventHadler(InputHandler input, Graphics g);\n\n        public event FrameEventHadler UpdateFrame;\n        public event FrameEventHadler DrawFrame;\nFinishing the constructor.\nAdd event handlers for input events of out baseControl control. Since code in each block is very short. Lets keep things concise and using another sytax sugar like inline event handlers. Especially if I pretty sure that almost never gonna change here anything.\n            baseControl.MouseMove += delegate (object sender, MouseEventArgs e) {\n                var mp = baseControl.PointToClient(Control.MousePosition);\n                curMouseLocation = new PointF(mp.X, mp.Y);\n            };\n            baseControl.MouseDown += delegate (object sender, MouseEventArgs e) {\n                var mp = baseControl.PointToClient(Control.MousePosition);\n                curMouseLocation = new PointF(mp.X, mp.Y);\n                if (!curMouseBtnDown.Contains(e.Button))\n                    curMouseBtnDown.Add(e.Button);\n            };\n            baseControl.MouseUp += delegate (object sender, MouseEventArgs e) {\n                var mp = baseControl.PointToClient(Control.MousePosition);\n                curMouseLocation = new PointF(mp.X, mp.Y);\n                if (curMouseBtnDown.Contains(e.Button))\n                    curMouseBtnDown.Remove(e.Button);\n            };\n            baseControl.MouseWheel += delegate (object sender, MouseEventArgs e) { \n                curWheelDelta += Math.Sign(e.Delta); \n            };\n            baseControl.KeyDown += delegate (object sender, KeyEventArgs e) {\n                if (!curKeysDown.Contains(e.KeyCode))\n                    curKeysDown.Add(e.KeyCode);\n                if (e.Alt && !curKeysDown.Contains(Keys.Alt))\n                    curKeysDown.Add(Keys.Alt);\n            };\n            baseControl.KeyUp += delegate (object sender, KeyEventArgs e) {\n                if (curKeysDown.Contains(e.KeyCode))\n                    curKeysDown.Remove(e.KeyCode);\n                if (!e.Alt && curKeysDown.Contains(Keys.Alt))\n                    curKeysDown.Remove(Keys.Alt);\n            };\n            baseControl.PreviewKeyDown += delegate (object sender, PreviewKeyDownEventArgs e) { \n                e.IsInputKey = true; \n            };\nAs you can see basically we input event hapens we just storing its value, adding pressed keys or removing keys that are not pressed anymore from the list. Maybe except the last one that just allow us to catch special keys, cause we need to catch all the keys and then decide depending on the task do we really need them or not.\n\nwhat’s left is:\n\nprevent from losing focus, cause Windows Forms really like this\nset timer to lowest possible interval of 1 millisecond, later I will cover how limit and make framerate more stable\non timer tick we force control to repaint itself\non paint event:\n\nwe need to save state from the last frame as previousState var, and create new InputState for currentState var but here is the problem we talked about if just directly assign previousState = currentState; we dont get a copy of current state we get reference to it. And what is gonna happen when we create a new state for currentState, previousState will have same content. This is why we using method InputState.GetCopy()\nand here is where our main game loop events are invoked, “?” sign after “.” means that events will be invoked only if they have subscribers.\n\n      // set focus to a form if mouse inside the window\n      baseControl.MouseEnter += delegate (object sender, EventArgs e) { \n          baseControl.Focus(); \n      };\n\n      // set timer interval to 1ms this will give as maximum frame rate\n      updateTimer.Interval = 1;\n\n      // on Timer Tick we call form to redraw ins contents\n      updateTimer.Tick += delegate { baseControl.Invalidate(); };\n\n      // on paint we get only graphics and send it to main function\n      baseControl.Paint += delegate (object sender, PaintEventArgs e) {\n          // store last input state as previous\n          previousState = currentState.GetCopy(); \n           // and create new input state out of current input data\n          currentState = new InputState(\n              new List&lt;Keys&gt;(curKeysDown.ToArray()),\n              new List&lt;MouseButtons&gt;(curMouseBtnDown.ToArray()),\n              new PointF(curMouseLocation.X, curMouseLocation.Y), curWheelDelta\n          );\n\n          // at last invoke game loop events\n          UpdateFrame?.Invoke(this, e.Graphics);\n          DrawFrame?.Invoke(this, e.Graphics);\n      };\n\n\nNow we reached the most important part, create properties and methods to get the all the information we need.\nProperties:\n        public PointF MouseLocationCurrent =&gt; currentState.Location;\n        public PointF MouseLocationPrevious =&gt; previousState.Location;\n        public PointF MouseOffset =&gt; new PointF(\n            currentState.Location.X - previousState.Location.X,\n            currentState.Location.Y - previousState.Location.Y);\n        public int WheelDelta =&gt; currentState.WheelPosition;\n        public int WheelDeltaOffset =&gt; currentState.WheelPosition - previousState.WheelPosition;\nMouseOffset is the most important just add it to any object position you want to move with a mouse and here you have smooth drag functionality.\nMethods:\n        public bool IsKeyDown(Keys key) =&gt; currentState.IsKeyDown(key);\n        public bool IsMouseDown(MouseButtons mb) =&gt; currentState.IsMouseDown(mb);\n        public bool IsJustMouseButtonPressed(MouseButtons mouseButton) =&gt;       \n            currentState.IsMouseDown(mouseButton) &&\n            !previousState.IsMouseDown(mouseButton);\n\n        public bool IsJustMouseButtonReleased(MouseButtons mouseButton) =&gt;     \n            !currentState.IsMouseDown(mouseButton) &&\n            previousState.IsMouseDown(mouseButton);\n\n        public bool IsJustKeyPressed(Keys key) =&gt; \n            (currentState.IsKeyDown(key) && \n            !previousState.IsKeyDown(key));\n        public bool IsJustKeyReleased(Keys key) =&gt; \n            (!currentState.IsKeyDown(key) && \n            previousState.IsKeyDown(key));\nThere is nothing sophisticated. If key was pressed in previous state but not in this state, here you have it, just released! Immediate Response in 1 frame / 60 frames / 1 sec!\nThat was quite a big tutorial. But undestanding of how this class works is vital before using it.\nIn the next tutorial I will cover Game Loop concept.\nNext &gt;&gt; : Game Loop\n&lt;&lt; Previous : Creating a Project"
  },
  {
    "objectID": "posts/Arkanoid/05/index.html",
    "href": "posts/Arkanoid/05/index.html",
    "title": "Arkanoid Series 05 : Game Loop",
    "section": "",
    "text": "Game Loop Etc.\n\n\n\nhttps://gameprogrammingpatterns.com/game-loop.html\n\n\nNext &gt;&gt; : Game menu\n&lt;&lt; Previous : Input handling"
  },
  {
    "objectID": "posts/news/00/index.html",
    "href": "posts/news/00/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Welcome to my game development blog!\nIn this blog, I want to share my little experiments in game programming. My goal is do not do it right, but to do it interesting.\nThe methods and tools that I use may seem outdated to some, but there are reasons for this. I value compilation and execution speed, rapid prototyping, convenience and code readability the most. After we were able to convey the general idea, the code can be easily translated into suitable tools for this. But at first those tools can distract from the original idea.\nI will not strive to make the complexity of the lessons consistent, those kind of lessons already exist, but I will use sophisticated methods straight away and explain them.\nI hope you get something useful for yourself.\nConsole.WriteLine(\"Hello and Welcome!\");"
  }
]